/* gnio.vapi generated by vapigen, do not modify. */

[CCode (cprefix = "G", lower_case_cprefix = "g_")]
namespace GLib {
	[CCode (cprefix = "G_SOCKET_DOMAIN_", cheader_filename = "gnio/gnio.h")]
	public enum SocketDomain {
		INET,
		INET6,
		LOCAL
	}
	[CCode (cprefix = "G_SOCKET_TYPE_", cheader_filename = "gnio/gnio.h")]
	public enum SocketType {
		STREAM,
		DATAGRAM,
		SEQPACKET
	}
	[CCode (cheader_filename = "gnio/gnio.h")]
	public class Inet4Address : GLib.InetAddress {
		public static weak GLib.Inet4Address from_bytes (uchar[] bytes);
		public static weak GLib.Inet4Address from_string (string str);
		public Inet4Address.any ();
		public Inet4Address.loopback ();
		public uchar to_bytes ();
	}
	[CCode (cheader_filename = "gnio/gnio.h")]
	public class Inet6Address : GLib.InetAddress {
		public static weak GLib.Inet6Address from_bytes (uchar[] bytes);
		public static weak GLib.Inet6Address from_string (string str);
		public Inet6Address.any ();
		public Inet6Address.loopback ();
		public uchar to_bytes ();
	}
	[CCode (cheader_filename = "gnio/gnio.h")]
	public class InetAddress : GLib.InitiallyUnowned {
		public virtual weak string to_string ();
		[NoAccessorMethod]
		public bool is_any { get; }
		[NoAccessorMethod]
		public bool is_link_local { get; }
		[NoAccessorMethod]
		public bool is_loopback { get; }
		[NoAccessorMethod]
		public bool is_mc_global { get; }
		[NoAccessorMethod]
		public bool is_mc_link_local { get; }
		[NoAccessorMethod]
		public bool is_mc_node_local { get; }
		[NoAccessorMethod]
		public bool is_mc_org_local { get; }
		[NoAccessorMethod]
		public bool is_mc_site_local { get; }
		[NoAccessorMethod]
		public bool is_multicast { get; }
		[NoAccessorMethod]
		public bool is_site_local { get; }
	}
	[CCode (cheader_filename = "gnio/gnio.h")]
	public class InetSocketAddress : GLib.SocketAddress {
		public weak GLib.InetAddress get_address ();
		public ushort get_port ();
		public InetSocketAddress (GLib.InetAddress address, ushort port);
		[NoAccessorMethod]
		public GLib.InetAddress address { get; construct; }
		[NoAccessorMethod]
		public uint port { get; construct; }
	}
	[CCode (cheader_filename = "gnio/gnio.h")]
	public class Resolver : GLib.Object {
		public Resolver ();
		public weak GLib.InetAddress resolve (string host, GLib.Cancellable? cancellable) throws GLib.Error;
		public void resolve_async (string host, GLib.Cancellable? cancellable, GLib.AsyncReadyCallback callback);
		public weak GLib.InetAddress resolve_finish (GLib.AsyncResult _result) throws GLib.Error;
		public weak GLib.List resolve_list (string host, GLib.Cancellable cancellable) throws GLib.Error;
		public void resolve_list_async (string host, GLib.Cancellable cancellable, GLib.AsyncReadyCallback callback);
		public weak GLib.List resolve_list_finish (GLib.AsyncResult _result) throws GLib.Error;
	}
	[CCode (cheader_filename = "gnio/gnio.h")]
	public class Socket : GLib.Object {
		public weak GLib.Socket accept () throws GLib.Error;
		public bool bind (GLib.SocketAddress address) throws GLib.Error;
		public void close ();
		public bool connect (GLib.SocketAddress address) throws GLib.Error;
		public weak GLib.TimeoutSource create_source (GLib.IOCondition condition, GLib.Cancellable cancellable);
		public bool get_blocking ();
		public weak GLib.SocketAddress get_local_address () throws GLib.Error;
		public weak GLib.SocketAddress get_remote_address () throws GLib.Error;
		public bool get_reuse_address ();
		public bool has_error () throws GLib.Error;
		public bool listen () throws GLib.Error;
		public Socket (GLib.SocketDomain domain, GLib.SocketType type, string? protocol);
		public Socket.from_fd (int fd);
		public long receive (string buffer, ulong size) throws GLib.Error;
		public long send (string buffer, ulong size) throws GLib.Error;
		public void set_blocking (bool blocking);
		public void set_reuse_address (bool reuse);
		[NoAccessorMethod]
		public int backlog { get; set; }
		public bool blocking { get; set; }
		[NoAccessorMethod]
		public GLib.SocketDomain domain { get; construct; }
		[NoAccessorMethod]
		public int fd { get; construct; }
		public GLib.SocketAddress local_address { get; }
		[NoAccessorMethod]
		public string protocol { get; construct; }
		public GLib.SocketAddress remote_address { get; }
		public bool reuse_address { get; set; }
		[NoAccessorMethod]
		public GLib.SocketType type { get; construct; }
	}
	[CCode (cheader_filename = "gnio/gnio.h")]
	public class SocketAddress : GLib.InitiallyUnowned {
		public static weak GLib.SocketAddress from_native (void* native, ulong len);
		public virtual long native_size ();
		public virtual bool to_native (void* dest);
	}
	[CCode (cheader_filename = "gnio/gnio.h")]
	public class SocketConnection : GLib.Object {
		public void close ();
		public bool connect (GLib.Cancellable? cancellable) throws GLib.Error;
		public weak GLib.SocketAddress get_address ();
		public SocketConnection (GLib.SocketAddress address);
		public SocketConnection.from_socket (GLib.Socket socket);
		public virtual void connect_async (GLib.Cancellable? cancellable, GLib.AsyncReadyCallback callback);
		public virtual bool connect_finish (GLib.AsyncResult _result) throws GLib.Error;
		[NoWrapper]
		public virtual bool connect_fn (GLib.Cancellable cancellable) throws GLib.Error;
		public virtual weak GLib.SocketInputStream get_input_stream ();
		public virtual weak GLib.SocketOutputStream get_output_stream ();
		[NoAccessorMethod]
		public GLib.SocketAddress address { get; construct; }
		public GLib.SocketInputStream input_stream { get; }
		public GLib.SocketOutputStream output_stream { get; }
		[NoAccessorMethod]
		public GLib.Socket socket { get; construct; }
	}
	[CCode (cheader_filename = "gnio/gnio.h")]
	public class SocketInputStream : GLib.InputStream {
		[NoAccessorMethod]
		public GLib.Socket socket { get; construct; }
	}
	[CCode (cheader_filename = "gnio/gnio.h")]
	public class SocketOutputStream : GLib.OutputStream {
		[NoAccessorMethod]
		public GLib.Socket socket { get; construct; }
	}
	[CCode (cheader_filename = "gnio/gnio.h")]
	public class SocketServer : GLib.Object {
		public weak GLib.SocketConnection accept (GLib.Cancellable cancellable) throws GLib.Error;
		public void accept_async (GLib.Cancellable cancellable, GLib.AsyncReadyCallback callback);
		public weak GLib.SocketConnection accept_finish (GLib.AsyncResult _result) throws GLib.Error;
		public void close ();
		public SocketServer (GLib.SocketAddress address) throws GLib.Error;
		[NoAccessorMethod]
		public GLib.SocketAddress address { get; construct; }
	}
	[CCode (cheader_filename = "gnio/gnio.h")]
	public class TCPConnection : GLib.SocketConnection {
		public TCPConnection (string hostname, ushort port);
		[NoAccessorMethod]
		public GLib.InetSocketAddress address { get; construct; }
		[NoAccessorMethod]
		public string hostname { get; construct; }
		[NoAccessorMethod]
		public uint port { get; construct; }
	}
	[CCode (cheader_filename = "gnio/gnio.h")]
	public class TCPServer : GLib.SocketServer {
		public weak GLib.TCPConnection accept (GLib.Cancellable cancellable) throws GLib.Error;
		public void accept_async (GLib.Cancellable cancellable, GLib.AsyncReadyCallback callback);
		public weak GLib.TCPConnection accept_finish (GLib.AsyncResult _result) throws GLib.Error;
		public void close ();
		public TCPServer (GLib.InetSocketAddress address) throws GLib.Error;
	}
	[CCode (cheader_filename = "gnio/gnio.h")]
	public const int IO_ERROR_ADDRESS_IN_USE;
	[CCode (cheader_filename = "gnio/gnio.h")]
	public const int IO_ERROR_RESOLVER_NOT_FOUND;
	[CCode (cheader_filename = "gnio/gnio.h")]
	public const int IO_ERROR_RESOLVER_NO_DATA;
}
